---
title: "OOV 해결하기 (1)"
excerpt: "Byte Pair Encoding"
toc: true
toc_sticky: true

author_profile: false

date: 2020-01-06 22:00:00 -0000
categories: 
  - NLP
tags:
  - 
---
## What is OOV?

OOV = '욕심꾸러기'

## setup
```python
import re, collections
from pprint import pprint
```
## 예제

### 단어 사전

corpus에서 주어진 `단어 : 빈도수` 사전이 다음과 같다고 가정하자.
```python
vocab = {'장 난 꾸 러 기 </w>': 5,
         '잠 꾸 러 기 </w>': 6,
         '장 난 감 </w>': 10,
         '잠 수 </w>': 3,
         '욕 심 </w>': 4}
```
띄어쓰기로 각 음절을 구분해 놓은 것에 주목해야 한다.

초기 단어 사전의 형태는 다음과 같다.
```python
initial_vocab = set()
for word in vocab.keys():
    symbols = word.split()
    initial_vocab.update(symbols[:-1])
pprint(initial_vocab)
```
```python
{'장', '욕', '감', '난', '수', '심', '러', '잠', '꾸', '기'}
```

### Byte 조합의 빈도수 계산 함수

```python
def get_stats(vocab):
    pairs = collections.defaultdict(int) # 값을 저장할 빈 dict
    for word, freq in vocab.items():
        symbols = word.split() # 띄어쓰기를 기준으로 분할
        for i in range(len(symbols)-1):
            pairs[symbols[i], symbols[i+1]] += freq
    return pairs
```
초기 단어 사전에 대해 어떤 결과가 나오는 지 살펴보자.
```python
pprint(get_stats(vocab))
```
```
defaultdict(<class 'int'>,
            {('감', '</w>'): 10,
             ('기', '</w>'): 11,
             ('꾸', '러'): 11,
             ('난', '감'): 10,
             ('난', '꾸'): 5,
             ('러', '기'): 11,
             ('수', '</w>'): 3,
             ('심', '</w>'): 4,
             ('욕', '심'): 4,
             ('잠', '꾸'): 6,
             ('잠', '수'): 3,
             ('장', '난'): 15})
```

<!--stackedit_data:
eyJoaXN0b3J5IjpbNDE5ODk5OTE3LDU4MTQzODc0LDU5MjIyMz
Q4MCwxNTgyNjYzMjc2XX0=
-->